\documentclass{article}
\usepackage{lmodern}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{textcomp}
\usepackage{underscore}
\usepackage{changes}
\usepackage{dcolumn}% Align table columns on decimal point
\usepackage{bm}% bold math
\usepackage{graphicx}
\usepackage{hyperref}
\hypersetup{colorlinks, citecolor=black, linkcolor=black, urlcolor=black} 

\usepackage{color}
\usepackage{listings}
\usepackage[caption=false]{subfig}
\usepackage[left= 2.5cm, right=2.5cm, top=2.5cm, bottom=2.5cm]{geometry}
\definechangesauthor[name={Eric}, color=red]{e}

\usepackage{longtable}
\newcommand{\consoleline}[2][0.5cm]
{\vspace{#1}
\textit{{#2}}
\vspace{#1}
}
\lstset{morecomment=[l]{\%}}
	
\title{Marlics User Guide}
\author{Renato Ferreira de Souza, Eric Koudhi Omori and Rafael Soares Zola}


\begin{document}

\maketitle

\section{Introduction}
  
Welcome to Marlics (\textbf{Mar}ingÃ¡ \textbf{li}quid \textbf{c}rystal
\textbf{s}imulator). Marlics is a software developed in C++ to
simulate the dynamics a liquid crystal order parameters by means of
finite differences. Our software is mainly intended to be used to
simulate non-curvilinear geometries were finite differences works very
well. We have provided two of such geometries: bulk and slab.
Non-curvilinear geometries can also be implemented if they are well
approximated by Cartesian grids. We have provided one of these
geometries: sphere.  Since we are providing the source code under a
GPL license, the user can implement their own geometries if needed.

The software usage is as follows: the user fills an input file choosing the
values of simulation parameters and the stage variables. This script
is passed to the software as a call variable. For ease of use we have
provided an example input file with the code, which can also be
visualized in section\ref{sec:inputfile}. Also, we have provided a
table with all variables for reference in section
\ref{sec:parameterlist}.


\section{Download and Compilation}

The marlics source code can be downloaded in Renato Ferreira de
Souza(Belanji) git-hub page
\footnote{https://github.com/Belanji/marlics}. If you use an Unix
system, the source code provides a makefile  to easy up the process of compilation.  Marlics needs
the following libraries installed on your system and reachable by the
compiler: gsl (Gnu scientific library) and BLAS. We provide two
examples in the make file, one we use the GSL BLAS, and other we use
the mkl library to provide the necessary functions.  After setting up
you just have to type:

\consoleline{\$ make}

Now, Marlics is already functional. If you prefer you can add an
shortcut (or a copy of the program) in a folder where your system can
reach automatically. In Unix system the folder searched by the system
when can be found in the variable \$PATH.


\section{Execution}

Executing Marlics is very straightforward, you call the program and
pass a input file as an argument. For example, if you
are using an Unix system and your marlics has an shortcut/copy in a
directory shown in the \$PATH. If your input file is named
``input\_file.txt'' you will launch Marlics typing (we provide an
example input file if you would like to try it in your console):


\consoleline{\$ marlics input\_file.txt}


\noindent to launch a instance of marlics using the ``input\_file.txt'' as input
file.

You will notice that the software display several lines of information
on your display, if you would like to save these lines to keep an log
of the simulation execution (which we strongly advise you to do so),
you can redirect the output direct to a file. In Unix systems this can
be done with the redirection operator $>$, which will create a new
file if it does not exist, otherwise it will overwrite the existing
file with the same name. If you would like to keep the previous
content in the file you are overwriting, you can use append operator
$>>$, however, we strongly advise against its use, since it can leave
the output files very difficult to understand.

Again as an example, if your settings is in a file named ``input\_file.txt'' and you would like to place the log information in a new$/$overwritten  output file named ``simulation.log'', you can do this by typing:

\consoleline{\$ marlics  input\_file.txt $>$simulation.log}

\section{Setting up your input file}\label{sec:inputfile}

All parameters and simulation setup are passed to marlics via the
input file. In this section we will describe how to set up your
simulation and how to chose the necessary parameters.

To help the user we provided an example input file with the program.

\subsection{Filling the input file}

To fill in an parameter value in the input file you need to include a
line with the parameter name followed by the parameter value (or values depending on the parameter informed) separated by any number of spaces:
\begin{lstlisting}
   parameter_name  value
\end{lstlisting}
Notice that any excess space will be ignored, also anything written
after the required parameter values (this is useful to let some
annotations about the parameters informed). For ease of the use, the
parameter names on marlics are not case sensitive.

Comments line can be placed in the input file initiating the line with
the symbol ``\#''. We strong recommend the user to place comments in
the input file in order to document it.

Be carefull since marlics accept multiple instances of the same
parameter, but will consider just the last one.


\subsection{Marlics parameters} \label{sec:parameterlist}

In marlics, some parameters are mandatory while others are optional,
some have standard values predefined or depends on others
parameters. In order to guide the input file construction, we present
a table containing a list of all defined parameters. In the list you
can find the parameters names, their units (the column is left in
blank when the parameter has no units or its adimentional) and
whenever it is mandatory or not. Note that whenever a parameter has an
standard value it will be informed in the `''mandatory/standard
value''. Also, whenever the parameter usage don't fit in any of the
previous cases, there is a reference to the section where you can find
more information.

\begin{center}
	\begin{longtable}{|c|c|c|c|}
          \hline 
          Parameter name  & variable type	& units & mandatory/standard value\\ 
          \hline 
          \hyperref[geometry]{Geometry}	& string & 	& Yes  \\ 
          \iffalse		\hline 
          R\_in&	double &  &  No \\ 
          \hline 
          R\_out&	double & & yes in sphere geometry  \\ 
          \fi		\hline 
          \hyperref[geometry]{Nx}	& integer &	& Yes \\ 
          \hline                                  
          \hyperref[geometry]{Ny}	& integer &      & Yes \\ 
          \hline                                  
          \hyperref[geometry]{Nz}	& integer &      & Yes \\ 
          \hline                                  
          \hyperref[geometry]{dx}	& real & nm      & Yes \\ 
          \hline                                  
          \hyperref[geometry]{dy}	& real & nm   & Yes \\ 
          \hline                                  
          \hyperref[geometry]{dz}	& real & nm	& Yes \\ 
          \hline 
          \hyperref[integrator.param]{integrator}	& string & & Yes\\ 
          \hline 
          facmin	& real &   & 0.4\\ 
          \hline 
          facmax	& real &   & 3\\ 
          \hline 
          prefac	& real &  & 0.8\\ 
          \hline 
          Atol	& real &  &0.001\\ 
          \hline 
          Rtol & real &  &0.001\\ 
          \hline 
          \hyperref[lc.param]{a} & real& MJ$/(m^2 K)$ & Yes\\
          \hline 
          \hyperref[lc.param]{b} & real& MJ$/m^2$ & Yes\\ 
          \hline
          \hyperref[lc.param]{c} & real& MJ$/m^2$ & Yes\\ 
          \hline 
          \hyperref[lc.param]{K1} & real &  pN  &  See \ref{lc.param}\\ 
          \hline
          \hyperref[lc.param]{K2} & real &  pN  &  See \ref{lc.param}\\ 
          \hline
          \hyperref[lc.param]{K3} & real &  pN  &  See \ref{lc.param}\\ 
          \hline 
          \hyperref[lc.param]{L1} & real &  pN & See \ref{lc.param}\\ 
          \hline 
          \hyperref[lc.param]{L2} & real &  pN & No   \\ 
          \hline
          \hyperref[lc.param]{ L3} & real & pN & No   \\ 
          \hline
          \hyperref[lc.param]{ Ls} & real & pN & No   \\ 
          \hline
          \hyperref[lc.param]{ Lq} & real & pN/m & No   \\ 
          \hline 
          \hyperref[lc.param]{p0 or q0} & real & nm or 1/nm & No \\ 
          \hline
          \hyperref[lc.param]{T}  & real & K	& No \\ 
          \hline 
          \hyperref[lc.param]{Mu or gamma} & real & Pa/s & Yes \\ 
          \hline 
          \hyperref[lc.param]{Mu\_s or gamma\_s} & real & nm Pa m/s&  See \ref{lc.param}\\ 
          \hline 
          \hyperref[time.param]{ti}& real & $\mu$s  & 0.0 \\ 
          \hline 
          \hyperref[time.param]{tf}& real & $\mu$s  & Yes\\ 
          \hline 
          \hyperref[time.param]{dt}& real & $\mu$s  & Tf/1e6 \\ 
          \hline 
          \hyperref[snapshot.param]{timeprint}& real & $\mu$s &  Tf/20 \\ 
          \hline 
          \hyperref[snapshot.param]{timeprint\_type}& string &  & Linear\\ 
          \hline 
          \hyperref[snapshot.param]{timeprint\_increase\_factor}& real&   & Tf/20 \\ 
          \hline 
          \hyperref[snapshot.param]{output\_folder}&	string & & . \\ 
          \hline 
          \hyperref[snapshot.param]{output\_fname}&	string & & director\_field\_\$\$.csv \\ 
          \hline 
          \hyperref[snapshot.param]{initial\_output\_file\_number} & int & & 0 \\ 
          \hline 
          \hyperref[ic.param]{initial\_conditions} & string & & yes \\ 
          \hline 
          \hyperref[ic.param]{initial\_file\_name} & string & & See \ref{ic.params} \\ 
          \hline 
          \hyperref[ic.param]{theta\_i} &	real & degrees & See \ref{ic.params} \\ 
          \hline 
          \hyperref[ic.param]{phi\_i} &	real & degrees  & See \ref{ic.params}\\ 
          \hline 
          \hyperref[ic.param]{rng_seed} &	int &  & time(NULL)\\ 
          \hline 
          \hyperref[boundary.params]{anchoring\_type} & int + string & & See \ref{boundary.params}\\ 
          \hline 
          \hyperref[boundary.params]{Wo1}& int + real & &  See \ref{boundary.params}  \\ 
          \hline 
          \hyperref[boundary.params]{theta\_0} &  int + real  & & See \ref{boundary.params} \\ 
          \hline 
          \hyperref[boundary.params]{phi\_0} &	 int + real  & & See \ref{boundary.params} \\ 
          \hline 
          \hyperref[field.params]{electric\_field\_x} &	 real  & V/$\mu$m & See \ref{field.params} \\ 
          \hline 
          \hyperref[field.params]{electric\_field\_y} &	 real  & V/$\mu$m & See \ref{field.params} \\ 
          \hline 
          \hyperref[field.params]{electric\_field\_z} &	 real  & V/$\mu$m & See \ref{field.params} \\ 
          \hline 
          \hyperref[field.params]{delta\_epslon} &	 real  & & See \ref{field.params} \\ 
          \hline 	
	\end{longtable} 
\end{center}

For more information about these parameters, check the following sections.


\subsection{Geometry parameters}\label{geometry}

The grid size and spacing is controlled with 6 parameters: $Nx$, $Ny$,
$Nz$ ,$dx$ ,$dy$ and $dz$. The number of points in each axis
directions is defined ny the parameters $Ni$, while the distance
between them is set by the parameters $di$.

The geometry parameter sets up the confinement of your liquid
crystal. Actually there are 3 different types of geometries available:
bulk, slab and sphere(experimental).

In \textbf{bulk} geometry, the liquid crystal is placed in an square box
with periodic boundary conditions in all directions, and therefore, no boundary conditions to be defined by the user.

In \textbf{slab} geometry, the liquid crystal is placed inside a box
with periodic boundary conditions in the x and y direction, and with
boundary conditions chosen by the user in both ends of the z
axis i.e. there is two boundary conditions to be defined by the user. 

Finally, in the \textbf{sphere} geometry the liquid crystal is placed
inside an sphere with radius $R=dx*Nx/2=dy*Ny/2=dz*Nz/2$. Here it
is imperative that you define the same number of points for $Nx$, $Ny$
and $Nz$, also it is important that the grid spacing is equal in any
direction i.e. $dx=dy=dz$. This geometry has one boundary condition
has to be defed and no periodic boundary conditions. Take note that,
since we are using a regular grid to define a curvilinear geometry,
the geometry resolution greatly depends on the grid sizes.

An example of geometry section is:

\begin{lstlisting}	
   geometry  slab
   Nx  200                /*      grid size      */
   Ny  200                /*      grid size      */
   Nz  100                /*      grid size      */
   dx  10.0               /*      10^-9 m         */
   dy  10.0               /*      10^-9 m         */
   dz  10.0               /*      10^-9 m         */
\end{lstlisting}

Which sets a slab with 200 points in the $x$ and $y$ axis and 100 in the $z$ one, and every point is separated by a distance of $10$ nanometers in each direction.

\subsection{Integrator}\label{integrator.param}

We have now  three integrator implemented in marlics: explicit euler (EULER), explicit second order Runge-Kutta (RK2) and the Dormand-Prince 5(4) (DP5), a time adaptive 5th order Runge-Kutta method.

The use of EULER and RK2 do not require any special parameters, you
just have to provide the line ``integrator'' and they are set to
use. Both integrators keep the time-step $dt$ constant during the
whole simulation.

The integrator DP5 uses a 5th order Runge-Kutta to propagate the
solution and a 4th order Runge-Kutta to estimate the error $err$. We
implemented the time-step control as presented by \textbf{cite the
  nordicks here later}. This implementation requires 5 additional
parameters: facmin, facmax, Atol, Rtol and prefac. facmax gives the
maximum increase factor of the time-step $dt$, while facmin gives its
maximum reduction. The values Atol and Rtol gives the the absolute and
relative error tolerances respectively. Finally prefac is safety
factor which multiplies the increase/decrease factor (we advise the
using prefac$=0.9$ or prefac$=0.8$).

 An example of integrator section would be:
\begin{lstlisting}
  integrator  DP5
  atol 0.005
  rtol 0.005
  facmax 3.0
  facmin 0.4
  prefac 0.8
\end{lstlisting}

\subsection{Liquid crystal Parameters}\label{lc.param}

In Marlics, we simulate the elastic behavior of a chiral, or non-chiral, nematics by solving the dynamic equations given by Landau-de Gennes 
model (please, see reference xx). This model needs a set of parameters: $a$, $b$, $c$, $T-T*$, $L_1$, $L_2$, $L_3$, $L_q$, $L_s$, $p_0$, $mu$, $mu_s$ which are set in the input file.

The parameters $a$, $b$ and $c$ are the thermodynamic parameters
together with the temperature $T$ defines: the equilibrium value of
the scalar order parameter $S$ and energy necessary to shift its
value. It is obligatory to define all of them and the they need to
fulfill the following constraints: $c$ can not be 0 and $a T$ has to
be lower than 0 to define a liquid crystal system. The temperature $T$
is taken relative to virtual phase transition temperature $T^*$, for
example:
\begin{lstlisting}	
   a   0.182
   b  -2.12
   c  1.73
   T -1            Kelvin
\end{lstlisting}
defines a liquid crystal at 1 degree lower than the virtual transition
temperature.

The parameters $L_i$ can be filled in two different ways. You can pass the values of $L_i$ directly , for example:
\begin{lstlisting}
   L1  7.26          /*  pN  */
   L2  18.8          /*  pN  */
   L3  1.91          /*  pN  */
   Ls  1.0           /*  pN  */
   Lq  3.42          /*  pN/nm  */
\end{lstlisting}


Or you can provide the values of the Frank elastic constant
$\lbrace K_{11}, K_{22}, K_{33}, K_{24} \rbrace$ and let marlics
calculates the values of $L_i$ as proposed in \cite{} (note that this
method uses the equilibrium vale of $S$ to calculate the values of
$L_i$). Example:

\begin{lstlisting}
   k11  16.7        /*   pN   */
   k22  7.8         /*   pN   */
   k33  18.1        /*   pN   */
   k24  0           /*   pN   */ 
\end{lstlisting}

As explained before, If you define both $K_i$ and $L_i$, or if you
insert multiple instances of these parameters, the software will use
only the last mentioned and ignore the others (We strong advise
against it, since it can make your input file very confusing).

In order to simulate a chiral nematic you need to define the helix
pitch, $p_0$, as the space necessary to the helix execute a $2 \pi$
turn (in nanometers). For example:

\begin{lstlisting}
   p0  500
\end{lstlisting}
Sets the pitch to be 500 nanometers.  In a alternative way, you can
define the chiral constant, $q_0$, given by $q_0=2 \pi /p_0$. 

Finally, the liquid crystal viscosities can be passed in two different
ways. You can pass constant the $\mu_1$ value directly, or pass the
parameter $\gamma$ as used in the Frank-Osen theory and let marlics
calculate the value of its value using $\mu_1=\gamma/S_{eq}$. The same can be done with the surface
viscosity $\mu_{1s}$ which can be passed directly or by means of $\gamma_s$. For example:
\begin{lstlisting}
   mu_1     0.3          %/*     Pa s            */
   mu_1_s   30.0          %/*     10 ^-9 Pa s     */
\end{lstlisting}
defines the values of $\lbrace \mu_1,\mu_{1s} \rbrace$, or by passing  
\begin{lstlisting}
   gamma     0.3          %/*     Pa s            */
   gamma_s   30.0          %/*     10 ^-9 Pa s     */
\end{lstlisting}


\subsection{Time parameters}\label{time.param}

There is 3 time parameters to be set in the input file. The parameter
$t_i$ and $t_f$ (in microseconds) defines respectively the start and
the end time of the simulation. The parameter $dt$ (in microseconds)
defines the time step, for a fixed time-step integrator, and the
initial one for an adaptive time integrator.  For example:
\begin{lstlisting}
   dt  0.001            %/*     10^-6 s         */	
   ti  0.0              %/*     10^-6 s         */	
   tf  5000.0           %/*     10^-6 s         */
\end{lstlisting}
set-up a simulation that starts at $t=0$ and finishes at $t=5 ms$. If
using a fixed time-step integrator the time steps will be taken with
an interval $dt=0.001 \mu s$, otherwise it will start the simulation
with a time-step $dt=0.001$ but this value will be adapted as the
simulation evolves.

\subsection{output parameters}\label{snapshot.param}


There are 3 parameters to control how snapshots are taken and 3 controlling the file names in Marlics. The parameters controlling the snapshot frequency are: \textit{timeprint}, \textit{timeprint_type}, \textit{timeprint_increase_factor}. The \textit{timeprint} sets the time when the first snapshot is taken (in microseconds). 

The \textit{timeprint_type} defines if the snapshots will be taken in
linear or logarithmic rate.  If \textit{timeprint_type} is set to
\textbf{linear}, then the value of \textit{timeprint_increase_factor}
is the time interval between snapshots. If \textit{timeprint_type} is
set to \textbf{logarithmic}, then the the snapshot number $s+1$ will
be taken at:
\begin{equation}
  t_{s+1}=t_s *\textrm{timeprint_increase_factor}
\end{equation}
where $t_s$ is the $S$th snapshot time and $t_{s+1}$ is the $(S+1)$th snapshot time. For example:
\begin{lstlisting}
   time_print_type             logarithmic
   timeprint                   50.        % /*  10^-6 s   */
   timeprint_increase_factor   1.16       % /*  10^-6 s   */     
\end{lstlisting}
sets the first snapshot to be taken at $t=50 \mu s$, while the
following ones will be taken at logarithmic rate with an increase
factor of 1.16.


The \textit{output\_folder} can be used to define a output directory
(the standard value is``.\textbackslash'', also known as ``current
folder'' in Unix system).  For naming your output files, you can use
the parameter \textit{output\_fname} to define a pattern (the standard
value is ``director\_field\_\$\$.csv'').  The given name must have a
``\$\$'' to be substituted for the snapshot number. For example:
\begin{lstlisting}
   output_folder  csv
   output_fname   output_$$.csv
   initial_output_file_number  0	
\end{lstlisting}
will produce the sequence ``output\_0.csv, output\_1.csv, output\_2.csv,...'' and so on, inside the folder ``csv''.  

\subsection{Initial Condtions}\label{ic.params}

Marlics provides 4 types of initial conditions: Random, homogeneous, random_bulk_homogeneous_easy_axis and read_from_file.

The \textit{Random} initial conditions gets random directors, however,
the nematic order parameter is set to $S=0.15 S_{eq}$ (there would be
no meaning leaving the order parameter fluctuating with high
variance).\added[id=e]{ You can define the random number generator seed with the parameter rng_seed, otherwise, Marlics will get from the function time(null).}

The \textit{homogeneous} initial conditions set the liquid crystal
order parameter at $S=S_{eq}$ and $P=0$ while all the directors are
set in the same direction. This direction is given by two parameters
\textit{theta_i} and \textit{phi_i}, the polar and azimuthal angles,
both in degrees units.

The \textit{random_bulk_homogeneous_easy_axis} sets the liquid crystal
as \textit{random} in the bulk and as \textit{homogeneous} in the
boundaries, in this case, the liquid crystal will be oriented along
the easy axis in the boundary, see section \label{ssec:boundary} for
more information

Finally, the \textit{read_from_file} take an marlics snapshot and use
it as initial conditions. The file name is passed by the variable
\textit{ic_file}.

One example of the initial condition setup would be:
\begin{lstlisting}
   initial_conditions  homogeneous
   theta_i             45.0
   phi_i               0.0	
\end{lstlisting}


\subsection{Boundary Conditions:}\label{boundary.params}

For each geometry you must setup a defined number of boundaries, each
boundary has a number which must be informed together with the
parameter yu want to set. In more details:

\textbf{slab}: you must define two boundaries in this geometry, the
top and the bottom wall containing the liquid crystal. The bottom wall
is referred by 0 while the top wall is referred by 1.

\textbf{sphere}: This geometry has one boundary to be defined, the
outer layer of the sphere, which is refereed by the number 0.

\textbf{bulk}: this geometry has no boundaries.

Actually there is 3 kinds of boundaries conditions implemented in
marlics: Rapini-Papoular(also called Nobili-Durant), Fournier-Galatola and strong
boundary conditions. Each boundary conditions requires some parameters
to be defined.

Boundary conditions that rely on a penalty function, like
  Rapini-Papoular and Founier-Galatola, requires an anchoring
intensity Wo1. Boundary condtions that rely on an easy axis for the
energy calculation, \textit{i.e.} Rapnini-Papoular and
  strong boundary, also need to define the easy axis by means of the
polar angle theta_0 and azimutal angle phi_0.

If you want to define a boundary condition, for example, of
Rapini-Papoular at the 0 wall of an sphere, you need to include:
\begin{lstlisting}
   anchoring_type 0  Rapini-Papoular.
   Wo1            0  1000.0
   theta_0        0  45.0
   phi_0          0  45.0	
\end{lstlisting}
and if you want to implement an Fournier and Galatola on the top
surface you must include:

\begin{lstlisting}
   anchoring_type 1  Fournier-Galatola
   Wo1            1  1000.0
\end{lstlisting}

\subsection{Electric Field}\label{field.params}

In Marlics, the electric field is homogeneous in the entire cell. In order to simulate it's effects 4 parameters are needed, the x, y and z components of the field (in volts by micrometers) and the dielectric anisotropy of the material. For example:

\begin{lstlisting}

electric_field_x 0.0                      /*     10^9 V/m        */
electric_field_y 0.0                      /*     10^9 V/m        */
electric_field_z 1.0                      /*     10^9 V/m        */
delta_epslon     5	
\end{lstlisting}

Will define a electric field for a positive dielectric anisotropy material.\\
\textbf{NOTE:} You need to define all the four parameters, or none of them, or Marlics will terminate with an error.

\subsection{Complete input file:}

Here you can find the complete input file:

\begin{lstlisting}	

   #Geometry Parameters:
   geometry  slab
   Nx  200                /*      grid size      */
   Ny  200                /*      grid size      */
   Nz  100                /*      grid size      */
   dx  10.0               /*      10^-9 m         */
   dy  10.0               /*      10^-9 m         */
   dz  10.0               /*      10^-9 m         */


  #Integrator parameters:
  integrator  DP5
  atol 0.005
  rtol 0.005
  facmax 3.0
  facmin 0.4
  prefac 0.8


  #Liquid crystal parameters:
  a   0.182
  b  -2.12
  c  1.73
  T -1            Kelvin
  k11  16.7        /*   pN   */
  k22  7.8         /*   pN   */
  k33  18.1        /*   pN   */
  k24  0           /*   pN   */ 
  p0  500
  mu_1     0.3          %/*     Pa s            */
  mu_1_s   30.0          %/*     10 ^-9 Pa s     */


  #Time parameters:
  dt  0.001            %/*     10^-6 s         */	
  ti  0.0              %/*     10^-6 s         */	
  tf  5000.0           %/*     10^-6 s         */

  #Output Parameters:
   time_print_type             logarithmic
   timeprint                   50.        % /*  10^-6 s   */
   timeprint_increase_factor   1.16            
   output_folder               csv
   output_fname                output_$$.csv
   initial_output_file_number  0	

   #Initial conditions:
   initial_conditions  homogeneous
   theta_i             45.0
   phi_i               0.0	

   #Boundaries conditions

   #Bottom boundaries:
   anchoring_type 0  Rapini-Papoular
   Wo1            0  1000.0
   theta_0        0  45.0
   phi_0          0  45.0	

   #Top boundaries:
   anchoring_type 1  Fournier-Galatola
   Wo1            1  1000.0

\end{lstlisting}
\section{Output files}

The output file produced by Marlics will use a csv(Coma Separated Values) format and each row from the exported file will correspond with a lattice of the simulated cell. In this file, you can see the following values:\\
\textbf{x, y, z:} corresponding with the x, y and z coordinates index of the lattice, you can obtain the ``real'' value multiplying with dx, dy and dz;\\
\textbf{nx, ny, nz:} gives the principal director .\\
\textbf{lx, ly, lz:} gives the secondary director.\\
\textbf{s, p:} gives the first and the second major eigenvalue of the tensorial order parameter.\\ 
\textbf{pt:} inform the point type of the lattice (0=outside point, 1=bulk point and 2=surface point).

The values used in the output file are also the values needed to use the ``read from file'' option to create the initial conditions. In case you are going to create your own initial condition file you need to pay attention in 2 things. The ic file need to use the following order of the values: ``x,y,z,nx,ny,nz,lx,ly,lz,S,P,pt''. All lattices should be defined, with any desired order, but in case of some lattice is missing Marlics will proceed with an warning. For ensure the consistence with the geometry defined the input file, the point types are redefined.



\end{document}
